PR00FPS:

rendering flow:
tmcsRender()

    glClear()
    ? mblur
    -> yes
        ...
    -> no
        SwitchToPerspective()
            projection matrix
            gluPerspective()
            glRotatef(Camera.anglex, Camera.angley, Camera.anglez)
            glTranslatef(-Camera.posx, -Camera.posy, Camera.posz)
            modelview matrix

        RenderAll()
            push()
                for all non-sticked objects ...
                    push()
                        glTranslatef(posx, posy, -posz)
                        glRotatef(anglex, angley, anglez)
                        glScalef(scaling, scaling, scaling)
                        Draw()
                    pop()
            pop()

            SwitchToOrthographic()
            for all sticked objects ...
                push()
                    glRotatef(anglex, angley, anglez)
                    glTranslatef(screenw/2, screenh/2, 0)
                    glTranslatef(posx, posy, posz)
                    glScalef(scaling, scaling, scaling)
                    Draw()
                pop()

            draw texts

    glFlush()
    SwapBuffers()


==============================================================================================


PRRE 2014. 02. 08.:

PRREReducedRenderingEngine
	Renderer
		RendererSWincremental
		RendererHWfixedPipe

rendering flow:
RendererHWfixedPipe::RenderScene()

    BeginRendering()
        glViewport()
        glScissor()
        glClear()

    SwitchToPerspectiveProjection()
        projection matrix
            myPerspective()
        modelview matrix
            myLookAt()

    Draw3DObjects()
        push()
            for all non-sticked objects ...
                ApplyTransformations()
                Draw() 1. VERTEX SPECIFICATION
        pop()

    SwitchToOrtographicProjection()
	    projection matrix
            glOrtho()
		modelview matrix
		    translate to screen center

    Draw2DObjects()
	    /* legacy 2D code begins */
	    push()
            for all sticked objects ...
                ApplyTransformations()
                Draw() 1. VERTEX SPECIFICATION
        pop()
		/* legacy 2D code ends */
		uiMgr.Render()

    FinishRendering()
		2. VERTEX PROCESSING
		3. PRIMITIVE (TRIANGLE) ASSEMBLY
		4. RASTERIZATION
		5. FRAGMENT PROCESSING
		6. PER-SAMPLE PROCESSING
        glFlush()
        SwapBuffers()


==============================================================================================


3D grafika beadandó swrenderer:

rajzolás:
Clear()
    DIB-et feltöltünk egy adott színnel
minden objektumra
    Draw()  RENDERING PIPELINE
        minden alobjektumra
            vertexek lemásolása  1. VERTEX SPECIFICATION
            minden vertexre
                ApplyTransformations()  2.1 VERTEX PROCESSING 1ST PART
            rajzolási mód
            -> pont
                minden háromszögre
                    minden vertexre (indexelt hivatkozás a másolatokra)
                        vetített 2D-koordináta számolás  2.2 VERTEX PROCESSING 2ND PART  3. PRIMITIVE (TRIANGLE) ASSEMBLY
                        SetPixel()  4. RASTERIZATION (TRIANGLE SETUP SKIPPED HERE)
						5. FRAGMENT PROCESSING SKIPPED
						6. PER-SAMPLE PROCESSING (Z-TEST SKIPPED HERE)
            -> vonal
                minden háromszögre
                    minden vertexre (indexelt hivatkozás a másolatokra)
                        vetített 2D-koordináta számolás  2.2 VERTEX PROCESSING 2ND PART  3. PRIMITIVE (TRIANGLE) ASSEMBLY
                    3x Line()  4. RASTERIZATION (TRIANGLE SETUP SKIPPED HERE)
						5. FRAGMENT PROCESSING SKIPPED
						6. PER-SAMPLE PROCESSING (Z-TEST SKIPPED HERE)
                        CohanSutherlandScissoring?
                        -> igen
                            CSScissor()
                            rajzolás módosított vetített koordinátákkal
                        -> nem
                            rajzolás eredeti vetített koordinátákkal
            -> kitöltés
                minden háromszögre
                    minden vertexre (indexelt hivatkozás a másolatokra)
                        vetített 2D-koordináta számolás  2.2 VERTEX PROCESSING 2ND PART  3. PRIMITIVE (TRIANGLE) ASSEMBLY
					4. RASTERIZATION (TRIANGLE SETUP)
                    háromszög legkisebb és legnagyobb vetített Y és sima Z értékeinek meghatározása
                    Haromszog()  
                        magassag = maxy - miny (ehhez kellettek a min/max vetített Y-koordok)
                        létrehozunk egy magassag+1 méretû tömböt, melynek elemei TElem-ek
                        minden TElemben a bal koord nagy szám, a jobb koord -1 lesz
                        a 3 vertexet vetített X-koordináta szerint sorrendbe rakjuk, tehát
                            [x1,y1,z1] lesz a bal szélsõ, [x3,y3,z3] a jobb szélsõ vertex
                        3x Oldal()
                            mind3 oldalra kiszámolja hogy milyen X-tõl és Z-tõl milyen X-ig és Z-ig tart és ezt minden sorban megcsinálja,
                            tehát végül meg fogjuk kapni a tömbben a teljes 3szög 2D-s körvonalát, csúcsok között interpolált Z-koordokkal
                            Gyakorlatilag triangle setup
                        minden magassag-ra
							5. FRAGMENT PROCESSING SKIPPED
							6. PER-SAMPLE PROCESSING (Z-TEST SKIPPED HERE)
                            Szakasz()
                                a korábban kiszámolt kezdõ és végpontok között vízszintes szakaszt rajzol
                                Line()
								CohanSutherlandScissoring?
								-> igen
									CSScissor()
									rajzolás módosított vetített koordinátákkal
								-> nem
									rajzolás eredeti vetített koordinátákkal
                                Z-buffer kezelés le van kommentezve valamiért
            


RenderAll()
    BitBlt()-vel a bufferünk tartalmát átmásoljuk az ablakba



==============================================================================================


https://github.com/flaming0/software-renderer/blob/master/renderer/rend/rendermgr.h

RenderMgr
	RenderList
	SoftwareRenderer : AbstractRenderer
		FrameBuffer
		WireframeTriangleRasterizer (megkap: framebuffer)
		FlatTriangleRasterizer (megkap: framebuffer)
		stb

Itt van egy rendermgr, ami abstractrenderer-t és renderlist-et tárol.
Abstractrenderer lehet szoftveres vagy opengl, opengl nincs implementálva.
A renderlist egy trianglelist, ami minden frame-en feltöltõdik, lásd alább:
Rendermgr::runFrame()
   1. VERTEX SPECIFICATION
   minden objektumra
     renderlist-hez hozzáadni
	   a renderlist végigmegy a megadott objektum vertexbufferén és háromszögek listáját megcsinálja (object->world transzformáció megtörténik)
	   minden objektum háromszöge egy nagy listába kerül (ezért háromszögekhez material infót is tárol, ami valszeg objektumspecifikus)
   2 VERTEX PROCESSING
   renderlist->removeBackfaces(camera)
      megjelöli a backface-eket a kamera alapján
   kamerával elvégezteti a renderlistben található triangle-ök world -> camera transzformációját
   kamerával frustum cullingoltat
   3. PRIMITIVE (TRIANGLE) ASSEMBLY
   kamerával Camera -> Perspective -> Screen transformation
   renderer-rel raszterizálja a renderlist-et (RenderWorld)
      tehát innentõl kezdve lenne különbség opengl vs szoftveres között
	  ami sztem hülyeség, mert opengl renderer esetén eleve nem kellene vertexbufferen végigmenve triangle-öket generálva
	  backface-cullolni, frustum cullolni, transzformálni ... '96-ban még okés volt igy felosztani, de '97-tõl kezdve
	  a trianglesetup és clipping már a vga-n ment, '99-tõl pedig megjelent a HW TnL, tehát a mindenféle transzformációt
	  ki lehetett hagyni a CPU-n, a GPU megcsinálta. Ezen felül, eleve már a VRAM-ban illik tárolni a geometriát manapság.
	  
	  szoftveresen belül:
	    4. RASTERIZATION (TRIANGLE SETUP)
	    végigmegy a háromszögeken (renderlist), mindegyikre:
			ha clippelve van (frustum culling vagy backface culling eredménye alapján), kihagy
			egyébként a triangle shademode-jától függõen (ami a material tulajdonsága), lehet valamelyik rasterizer:
				wireframe, flat, gouraud, texture
				5. FRAGMENT PROCESSING
				6. PER-SAMPLE PROCESSING
			a rasterizer a megadott háromszöget rasterizálja, a framebuffer-t megkapja és annak metódusával irja a megfelelõ pixeleket


==============================================================================================


https://github.com/BennyQBD/3DSoftwareRenderer/tree/master/src

Main
	Display
		RenderContext (framebuffer)
			ez foglalkozik a konkrét raszterizálással háromszögenként, zbuffer, stb
	main()
		mesh-ek betöltése
		végtelen ciklus
			minden mesh-re
				Mesh->Draw()
					minden háromszögre (3 indexenként végigmenve a vertexeken)
						RenderContext->DrawTriangle()
			Display->SwapBuffers()

==============================================================================================


Textúra betöltés JointFuture TextureManager alapján:

CreateTextureFromImageInstanceQ_ID(CJFImageImplementation* img, TJF_TEX_QUALITY quality, GLuint id)
    - ha van már ilyen textúra betöltve, visszaadjuk azt, egyébként
    - be kell tölteni a textúrát
        - img már megvan, tehát fájlmûvelet itt már nem lesz
        - buffertocreatetexturefrom az img pixeljeire mutat, gentexture, bindtexture
        - min filter, mag filter, anisotropy, pixelcomponentorder, internalformat
        ? quality
            -> !high
                ? img.mipmapcount
                    -> == 1
                        - generálunk egy új, ideiglenes textúrát mip map-ekkel (newtexture) az img-bõl: gen, bind
                        - lefoglalunk egy új buffert (newbuffer), amibe a KÉRT méretû textúra befér
                        - lekérjük a nextexture megfelelõ mip map szintjét a newbuffer-be
                        - töröljük a newtexture-t, bind vissza a készülõ textúrára
                        - buffertocreatetexturefrom = newbuffer
                    -> != 1
                        - dealing with quality later ...  
        ? mipmapping
            -> kell
                ? img.mipmapcount
                    -> == 1
                        - feltöltjük a textúrát mip map generálással buffertocreatetexturefrom-bõl
                    -> != 1
                        - ez az eset nyilván DDS-nél van, tehát eleve tömörített formában van meg nekünk az egész
                        - feltöltjük egyesével a már tömörített formában tárolt mip map-eket az img-bõl
                            - itt úgy foglalkozunk a quality-vel, hogy csak a megfelelõ szinttõl kezdve töltünk fel
                - lekérjük a végleges format-ot és kiszámoljuk a size-t
            -> nem kell
                ? img.mipmapcount
                    -> == 1
                        - feltöltjük a textúrát simán buffertocreatetexturefrom-bõl
                        - lekérjük a végleges format-ot és kiszámoljuk a size-t
                    -> != 1
                        - feltöltjük a textúrának csak a 0. szintjét tömörített formában
    - kész, visszaadjuk


==============================================================================================