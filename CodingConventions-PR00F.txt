/*
    ###################################################################################
    CodingConventions-PR00F.txt
    PR00F's Coding Conventions
    EMAIL : PR0o0o0o0o0o0o0o0o0o0oF88@gmail.com
    ###################################################################################
*/


1. Naming conventions
=====================

 A - local / non-const global / non-const member variables: Hungarian notation and lowerCamelCase, like:
     pPointer, nCount, sPlayerName, etc ...

 B - all function names including class member functions should use lowerCamelCase or UpperCamelCase, depending on the return value:
     - lowerCamelCase when the function has a return value
     - UpperCamelCase when the function doesn't return anything (void function)

 C - macro, struct, enum, enum constants and global / member const definitions: UPPERCASE_WITH_UNDERSCORES, like:
     MY_MACRO, MY_STRUCT, MY_ENUM, MY_CONST

 D - class names: UpperCamelCase, like:
     MyMathClass


2. Source formatting
====================

 A - opening comment: every file should contain an opening comment describing the content of the file and contact info, like:
     /*
        ###################################################################################
        MyFileXYZ.cpp
        This file is part of Project XY.
        TODO: External/Internal header.
        MyFileXYZ class.
        Made by PR00F88
        EMAIL : PR0o0o0o0o0o0o0o0o0o0oF88@gmail.com
        ###################################################################################
     */

 B - class definitions in header files:
     - comment before class definition should contain API usage by the class, for example:
       This class doesn't use any API directly.
       This class directly uses OpenGL.

     - member definition order (from left to right):
       - public, protected, private;
       - static, non-static;
       - const, non-const.

     - a comment line should divide member variables from member functions, and static members from non-statics:
       // ---------------------------------------------------------------------------

     - opening and closing braces always stand alone in their own lines

     - align member variable and function declarations to form columns: type, name, etc ... for example:
       int         nCount;
       std::string sName;
       bool        bInitialized; 
	      
     - when a ctor has an initializer list, the colon should be after the name of the ctor in the same line, and
       list elements should be under in separate lines, example:
       class ClassXY
       {
           int x, y;
       public:
           ClassXY() :
             x( 2 ),
             y( 5 )
           {}
       }

 C - class definitions in cpp files:
     - member definition order rule is same as in the header files;

     - opening and closing braces always stand alone in their own lines;

     - single comment lines should divide public, protected and private members, like:
       // ############################### PUBLIC ################################
       ...
       // ############################## PROTECTED ##############################
       ...
       // ############################### PRIVATE ###############################
       ...

     - if there are multiple classes in the same cpp file, they should be divided also by comments, like:
       /*
          MyClass1
          ###########################################################################
       */
         ...
       /*
          MyClass2
          ###########################################################################
       */

     - when a ctor has an initializer list, rule about colon and list elements are same as in the header file;

 D - a comment should be always placed after including a precompiled header, like:
     #include "MyHeader.h"  // PCH

 E - use 4 space characters instead of 1 tab character for indentations (this may not apply within comment blocks)

 F - opening and closing braces always stand alone in their own lines

 G - "else" statements also stand alone in their own lines, like:
     if ( ... )
     {
         ...
     }
     else
     {
         ...
     }

 H - pad parenthesed expressions with spaces, like
     if ( cond1 && cond2 ) ...

 I - local and global variables declared under each other should be aligned as mentioned at class definitions (2B)

 J - when declaring a pointer or reference, put the * or & char right after the typename it points or refers to, for example:
     
	 instead of these:
     i  - char *ptr;
     ii - char &ref;

     use these:
     i  - char* ptr;
     ii - char& ref;

 K - if there is not enough space within a line for a function prototype and wrapping should be applied, then wrap it right after
     the opening parentheses so the first argument goes into the next line. All lines after the first line should be indented.
     This rule applies to both declaring and defining a function. Example:

     void LongLongLongFunctionPrototypeExample(
        int arg1, arg2, arg3, arg4,
        bool arg5, void* arg6);

 I - a line shouldn't be longer than ~150 chars.


3. File handling
================

 A - put each class declaration into separate header files, use 1 file for multiple classes only when it makes sense to put them together into 1 file

 B - make separate .cpp file for each header file for class definitions. This is very important if we are making a library, to ensure everything will go into
     the generated static library, so no unresolved external symbol problem will happen when we try to use the library from some other program. See also 5A.

 C - file names should properly suggest their content. When containing a class, the file name should be the class name, for example:
     MyClass.h and MyClass.cpp contain the declaration and definition of MyClass.

 D - minimize including headers in header files when possible. Use the following techniques to minimize includes:
     - if a header is only included because a class name is used, then dont include the header, instead forward declare the named class;
     - use minimized STL headers if applicable, like iosfwd instead of iostream, etc.
     - see CppHeaderFileGuidelines.pdf

 E - MyClass.cpp should include MyClass.h first, then all the other needed headers (only exception is the precompiled header mentioned in next point);

 F - precompiled header files should be included only in .cpp files.
	 Precompiled headers must be the first included headers in .cpp files.
	 If precompiled header is at different level directory-wise, you have to make sure its location is also updated in cpp file properties:
     you can set the precompiled headers per each cpp file: right click on cpp > Properties > C/C++ > Precompiled Headers > Precompiled Header File should be relative path.


4. Strict coding
================

 A - use precision specifier letters as much as you can in floating-point literals, like:
     
	 float f = 5.0f
     
	 instead of
     float f = 5.0 (defaults to double)

 B - use "const" everywhere as much as you can, for every member function, returned pointer/reference, local / global variables, etc.
     
	 For formal parameters, don't over-use const! The rule is to use it only if it's makes sense for the caller, for example:
     
	 use
       i   - void print(const char* text) {...};
       ii  - void f(const MyClass& text) {...};
       iii - void g(int num) {...};
     
	 instead of:
       i   - void print(const char* const text) {...};
       ii  - void f(MyClass& text) {...};
       iii - void g(const int num) {...};
     
	 when we don't want to change the given entity on the outside.

 C - use const references as read-only parameters only when the passed parameter will be used only to read from AND it's not a small, single type. Good examples:
     
	 void f(const BigClass& a);  // we just read 'a' and won't modify it, won't even copy it to modify locally
     void f(int a);       // intentionally not a const-reference because int is a single type, using reference here may reduce performance a bit!
     void f(BigClass a);  // do this when although you don't have to modify the object on the outside but need a local non-const copy of it, this could be faster
                             than manually copying it!

     See next point also for exception!

 D - const references as read-only parameters should also be used for small types when defining class ctors and operators.
     This is for achieving a consistent parametering rule.

 E - use references as parameters instead of pointers where you can, to avoid extra null-checking and for better readability;

 F - make functions inline ONLY WHEN the function is small AND doesn't call another function!

 G - structs should be used as simple data containers without own functionality, so put only data members into them.
     Exception: simple ctors can be allowed just to initialize the members with PREDEFINED values (no dynamic memory allocation, etc...).

 H - don't forget to make private not only the ctor/dtor of singleton classes but also the copy ctor and assignment operator.
     This also applies to non-singleton classes which doesn't support copying / assigning yet.
     private:
         ClassXYZ(const ClassXYZ&) {}; 
         ClassXYZ& operator=(const ClassXYZ&) { return *this; };

 I - use the "explicit" keyword for 1-param non-copy ctors, for example:
     class XYZ
     {
         explicit XYZ(int count) { ... }
     }

 J - always declare dtors virtual!

 K - never put "using" statement into a header file!

 X - comments MUST BE UPDATED RIGHT AFTER modifying a function, etc.


5. In case of API development
=============================

 A - to ensure everything goes into the generated lib file, create cpp files for each header file (3B) and put all implementation into the cpp file.
     This applies also to empty methods, like an empty ctor, etc.

 B - you may declare and define the following class methods to avoid auto-generation by the compiler (C++98/03): 
     default ctor, copy ctor, dtor, copy assignment operator. This is to avoid unexpected hidden method generation by the compiler that may screw up
     the theoretical layout of your object.

 C - you don't know how a class coming from a public header and library really looks like - thus you can't make any assertions about how to correctly
     call its methods: you call a method which may end up in another method in practice.

 D - if a library we are using in external program changes, it's better to do a clean rebuild to avoid strange problems (~fragile binary interface problem).
     We dont have to do full rebuild if the Pimpl idiom (5F) is used.

 E - if we are creating a base class and some other class may be derived from our base class, the derived class may override some methods in the base class
     which can change the behavior of the base class itself - if the derived overrides a method that is actually used in the base class by some other method
     (~fragile base class problem). This can be avoided for published classes if the Pimpl idiom (5F) is used.

 F - the Pimpl idiom: http://c2.com/cgi/wiki?PimplIdiom .
     - change the class by putting all the private members into another class, this will be the implementation class defined in the cpp file hidden from outside world;
     - put the implementation class definition in the .cpp file;
     - put forward declaration of the impl class in the external header file (there will be 1 header file only which can be published with the static lib itself);
       note: forward declaration can go into the private part of the class right before the ptr mentioned next;
     - in the class definition, declare a (smart) pointer to the hidden class instance as the only private member variable (this private ptr will be seen though);
     - most public methods in the public class just simply call the methods of the impl class (this is a redirection actually);
     - some public method implementations may stay in the public class, especially when they call protected members;
     - all protected methods in the public class should stay there with the actual implementation so descendants can actually use them;
     - minimize protected members as possible - so hide the implementation details as possible;
     - public class is the friend of the implementation class;
     - ctors, copy ctors, assignment operators of the implementation should be private since no class will descend from these classes and we should stop
       everyone "accidentally" instantiating such classes from some nasty custom code;
     - the ctors of the public class need to create the hidden class instance;
     - the dtor of the public class needs to destroy the hidden class instance (possibly implicitly due to use of a smart pointer);
     - the assignment operator and copy ctor need to copy the implementation class instance appropriately or else be disabled.
     
	 Note: whenever a function in the public class is called, usually some function or data in the hidden half is needed to complete the request.
     That’s fine and reasonable. But as discussed already, sometimes a function in the Pimpl must call a nonprivate or virtual function in the visible class.
     In that case, it needs a pointer to the visible class. Recommended option: pass this as a parameter to the Pimpl functions (e.g., pimpl->func(this, params) ).
     http://herbsutter.com/gotw/_100/

     Since the public class in the header will be public for the user, comments for the public class should be left there.
     In the cpp file, duplicate comments should be avoided.
     In the cpp file, the implementation class definition shouldn't have the comments copied from the header.
     Also, the implementation of member functions of the implementation class shouldn't have comments if those functions are indirectly called from the public class.
     This means that in the cpp file, detailed comments of the methods of the public class should be placed at the implementation of the methods of the public class
     and not at the implementation of the methods of the implementation class.

 G - Interfaces instead of pimpls.
     You should think about how your public class will be used by users: in case it will be used by value, like it will be copied, passed to functions, etc., then
     that class should use the pimpl idiom (5F). However, if the class will be used as an entity, like a singleton, then that class should be an interface, a
     pure virtual class (or at least abstract if derived from some other class), with a static factory function, and the implementation should be put into the cpp file.
     The static factory should create and return a new instance of the implementation class derived from the public class.
     Default ctor, copy ctor, dtor, copy assignment operators may not be defined by the user for abstract classes since they can't be instantiated anyway.
     
     Since the interface will be public for the user, comments for the public class should be left there.
     In the cpp file, duplicate comments should be avoided.
     In the cpp file, the implementation class definition shouldn't have the comments copied from the header.
     Detailed member function comments should be placed right at their implementations.

 H - Singleton pimpl instead of interface.
     Sometimes you'd choose interface style for your class because it should be used as a singleton entity but on the other hand you'd like your class to be deriveable.
     In this case, simply use the pimpl idiom while the class remains as a singleton.